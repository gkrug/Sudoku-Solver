From the user's perspective, a SudokuSolver object can be instantiated with the name of the puzzle file as an argument in the non-default constructor. The puzzle can be solved and printed out using the solve and print member functions. When the program is executed, each unsolved puzzle is printed out followed by the solved version of the puzzle. As the user can see, each mini-grid, row, and column contains exactly one of the numbers 1-9. The program successfully solves the easy and the medium puzzles.

Internally, when the program is executed, the non-default-constructor takes the name of the puzzle file as an argument, and reads in the values of the sudoku puzzle into a 2-d vector. Additionally, in the non-default constructor, a 3-d possibilities vector is initialized. The outer dimension represents the possible values of the cell. If it is a 1, then it is a possibility. Otherwise, a zero indicates that the value is no longer a possibility for the cell. the second dimension represents an individual cell in a particular row. Last, the third dimension represents a row of cells with their respective possibilites. Whenever, a value is entered into a cell, all the possible values for the cell are set to 0. The solve member function contains a scanning elimination algorithm that loops through each cell in the puzzle, and eliminates possible values based on other values contained in its mini-grid, row, or column. For each cell, the single_block, single_row, and single_column functions are called to eliminate possibilities. These functions take the cell location and possible value as arguments, and checks if the possible value is already contained in the mini-grid, row, or column. If this is the case, the possibilities vector sets the possible value equal to zero at the given location. During the scanning process, if a cell is found in a mini-grid, row, or column with a unique possible value, then that value is assigned to the cell in the actual puzzle vector. Once there are no longer any zeros in the puzzle vector, then the program ends and the user is informed that puzzle is solved.

In order to verify the output of the program, I performed multiple tests. First, I instantiated two SudokuSolver objects with the easy and medium sudoku puzzle files posted on piazza. After I ran the program based on these two puzzle files, I ensured that the puzzle was accurately solved by checking each mini-grid, row, and column for exactly one of the numbers 1-9. Once I determined that these two puzzles were solved correctly, I checked additional easy and medium sudoku puzzles posted on the internet. Ultimately, I verified the accuracy of my sudoku solver once I observed that easy and medium puzzles were solved consistently.

I believe that the singleton algorithm was an effective strategy to solve the provided puzzles. The three dimensional possibilities vector was an appropriate data structure to carry out the scanning elimination algorithm. The program was able to loop through each cell possibility, and efficiently eliminate a possible value in the three dimensional vector. Once a cell contained a unique possibility, it could be determined that the value could be assigned to the puzzle vector. The three dimensional vector worked well because it allowed an efficient implementation of the singleton algorithm. On the other hand, however, the scanning elimnation algorithm did not work as well with very difficult sudoku puzzles. That is, with fewer given values, the algorithm would not solve the puzzle if no cell contained a unique possible value.
